<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Our Time Capsule</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Pacifico&family=Comfortaa:wght@700&family=Righteous&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('static', filename='css/style.css') }}"
    />
  </head>
  <body>
    <div class="container">
      <header>
        <div class="header-left">
          <img
            src="{{ url_for('static', filename='images/logo.png') }}"
            alt="Logo"
            class="logo"
          />
        </div>
        <h1 class="time-capsule-title">Tembusu UTCP Graduation</h1>
        <a href="/record" class="btn-record">+ Capture Moments</a>
      </header>

      <!-- Pagination Info Display -->
      {% if pagination.total_media > 0 %}
      <div class="pagination-info">
        <span
          >Page {{ pagination.current_page }} of {{ pagination.total_pages
          }}</span
        >
        <span class="separator">|</span>
        <span
          >Items {{ pagination.start_idx }}-{{ pagination.end_idx }} of {{
          pagination.total_media }}</span
        >
      </div>
      {% endif %}

      <div class="media-grid" data-count="{{ media_files|length }}">
        {% if media_files %} {% for item in media_files %}
        <div
          class="media-item"
          data-filename="{{ item.filename }}"
          data-type="{{ item.type }}"
        >
          {% if item.type == 'video' %}
          <video autoplay muted loop playsinline>
            <source
              src="{{ url_for('static', filename='videos/' + item.filename) }}"
              type="video/mp4"
            />
            Your browser does not support the video tag.
          </video>
          {% else %}
          <img
            src="{{ url_for('static', filename='videos/' + item.filename) }}"
            alt="Photo"
            loading="lazy"
          />
          {% endif %}
        </div>
        {% endfor %} {% else %} {% if pagination.current_page > 1 %}
        <!-- Empty page (not the first page) -->
        <div class="no-media">
          <p>No items on this page</p>
          <a href="/?page=1" class="btn-record">‚Üê Back to first page</a>
        </div>
        {% else %}
        <!-- No media at all -->
        <div class="no-media">
          <p>No memories yet!</p>
          <a href="/record" class="btn-record">Capture your first moment</a>
        </div>
        {% endif %} {% endif %}
      </div>
    </div>

    <!-- Navigation Arrows -->
    {% if pagination.total_pages > 1 %}
    <nav class="page-navigation">
      {% if pagination.has_prev %}
      <a
        href="/?page={{ pagination.prev_page }}"
        class="nav-arrow nav-prev"
        title="Previous Page"
      >
        <div class="arrow-container">
          <svg
            width="40"
            height="40"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M15 18L9 12L15 6"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span class="page-label">Page {{ pagination.prev_page }}</span>
        </div>
      </a>
      {% endif %} {% if pagination.has_next %}
      <a
        href="/?page={{ pagination.next_page }}"
        class="nav-arrow nav-next"
        title="Next Page"
      >
        <div class="arrow-container">
          <svg
            width="40"
            height="40"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M9 18L15 12L9 6"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
          <span class="page-label">Page {{ pagination.next_page }}</span>
        </div>
      </a>
      {% endif %}
    </nav>
    {% endif %}

    <script>
      function calculateOptimalGrid() {
        const grid = document.querySelector(".media-grid");
        const mediaCount = parseInt(grid.dataset.count) || 0;

        if (mediaCount === 0) return;

        // Get the header height and pagination info height
        const header = document.querySelector("header");
        const paginationInfo = document.querySelector(".pagination-info");
        const headerHeight = header.offsetHeight;
        const paginationHeight = paginationInfo
          ? paginationInfo.offsetHeight
          : 0;

        // Calculate available space
        const padding = 10;
        const gap = 5;
        const availableHeight =
          window.innerHeight -
          headerHeight -
          paginationHeight -
          padding -
          gap * 2;
        const availableWidth = window.innerWidth - padding;

        // Find the best grid layout
        let bestLayout = null;
        let maxItemArea = 0;

        for (let cols = 1; cols <= mediaCount; cols++) {
          const rows = Math.ceil(mediaCount / cols);

          const itemGap = 3;
          const totalGapWidth = (cols - 1) * itemGap;
          const totalGapHeight = (rows - 1) * itemGap;

          const maxItemWidth = (availableWidth - totalGapWidth) / cols;
          const maxItemHeight = (availableHeight - totalGapHeight) / rows;

          let itemWidth, itemHeight;
          const targetRatio = 16 / 9;

          if (maxItemWidth / maxItemHeight > targetRatio) {
            itemHeight = maxItemHeight;
            itemWidth = itemHeight * targetRatio;
          } else {
            itemWidth = maxItemWidth;
            itemHeight = itemWidth / targetRatio;
          }

          if (
            itemWidth * cols + totalGapWidth <= availableWidth &&
            itemHeight * rows + totalGapHeight <= availableHeight
          ) {
            const area = itemWidth * itemHeight;
            if (area > maxItemArea) {
              maxItemArea = area;
              bestLayout = {
                cols: cols,
                rows: rows,
                width: itemWidth,
                height: itemHeight,
                totalWidth: itemWidth * cols + totalGapWidth,
                totalHeight: itemHeight * rows + totalGapHeight,
              };
            }
          }
        }

        if (bestLayout) {
          const mediaItems = document.querySelectorAll(".media-item");
          mediaItems.forEach((item) => {
            item.style.width = `${bestLayout.width}px`;
            item.style.height = `${bestLayout.height}px`;
          });

          grid.style.gridTemplateColumns = `repeat(${bestLayout.cols}, ${bestLayout.width}px)`;
          grid.style.gridTemplateRows = `repeat(${bestLayout.rows}, ${bestLayout.height}px)`;
          grid.style.width = `${bestLayout.totalWidth}px`;
          grid.style.height = `${bestLayout.totalHeight}px`;
          grid.style.margin = "auto";
          grid.style.display = "grid";
        }
      }

      // Initial calculation
      setTimeout(calculateOptimalGrid, 50);

      // Recalculate on window resize
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(calculateOptimalGrid, 100);
      });

      // Handle click on media item to delete
      document.querySelectorAll(".media-item").forEach((item) => {
        item.addEventListener("click", async (e) => {
          const type = item.dataset.type;
          const typeText = type === "video" ? "video" : "photo";

          if (confirm(`Delete this ${typeText}?`)) {
            const filename = item.dataset.filename;
            const encodedFilename = encodeURIComponent(filename);
            const response = await fetch(`/delete/${encodedFilename}`, {
              method: "DELETE",
            });
            if (response.ok) {
              // Get current page from URL
              const urlParams = new URLSearchParams(window.location.search);
              const currentPage = urlParams.get("page") || "1";

              // Reload the current page to refresh the media list
              window.location.href = `/?page=${currentPage}`;
            } else {
              const error = await response.json();
              alert(
                `Failed to delete ${typeText}: ${
                  error.error || "Unknown error"
                }`
              );
            }
          }
        });
      });

      // Keyboard navigation support
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          const prevArrow = document.querySelector(".nav-prev");
          if (prevArrow) {
            prevArrow.click();
          }
        } else if (e.key === "ArrowRight") {
          const nextArrow = document.querySelector(".nav-next");
          if (nextArrow) {
            nextArrow.click();
          }
        }
      });
    </script>
  </body>
</html>
